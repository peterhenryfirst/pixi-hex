<!DOCTYPE HTML>
<html>
<head>
	<title>pixi.js example 1</title>
	<style>
		body {
			margin: 0;
			padding: 0;
			background-color: #000000;
		}
	</style>
	<script src="javascripts/pixi/pixi.dev.js"></script>
</head>
<body>
	<script>
		// create an new instance of a pixi stage
		var WIDTH = 700;
		var HEIGHT = 300;
		var stage = new PIXI.Stage(0x66FF99);

		// create a renderer instance.
		//var renderer = PIXI.autoDetectRenderer(WIDTH, HEIGHT);
		//var renderer = new PIXI.autoDetectRenderer(1024, 768, null, true, true);
		var renderer = new PIXI.WebGLRenderer(WIDTH, HEIGHT);

		// add the renderer view element to the DOM
		document.body.appendChild(renderer.view);

		//requestAnimFrame( animate );


		var loader = new PIXI.AssetLoader(['spritesheet/hex-tiles.json']);

		// map
		var G=0, D=1, W=2;
		/*
		var terrain = [
			[G, G, G, G, W],
			[D, D, G, G, W],
			[D, G, G, W, W],
			[D, G, W, W, W],
		];
		*/

		var terrain = [];

		for (var i = 0, iL = 5; i < iL; i++) {
			terrain.push([G,W,D,W,G,D,W,D,W]);
		}


		// Tiles with height can exceed these dimensions.
		var tileHeight = 89;
		var tileWidth = 65;
		
		//division 65/80 = 0.8125, for the future this division is useful and use that number for the tile anchor exact value

		var size = 65;
		var sqrt3 = Math.sqrt(3);
		var anchor = {
			x: 0.5,
			y: (size * 0.5) * 0.5 / (tileHeight * 0.5)
		};

		// tiles
		var grass = isoTile('tileGrass.png');
		var dirt = isoTile('tileDirt.png');
		var water = isoTile('tileWater.png');
		var sand = isoTile('tileSand.png');
		var tileMethods = [grass, dirt, water, sand];
		
		function convertAxialToPixel(q, r) {
			var x = size * (q + r * 0.5);
			var y = r * size * 3/ 4;
			/*
			var x = size * sqrt3 * (q + r / 2);
			var y = size  * 3 / 2 * r;
			/**/
			return {x:x,y:y};
		}
		
		function euclideanDistance(p0, p1) {

			return Math.sqrt(Math.pow(p0.x - p1.x, 2) + Math.pow(p0.y - p1.y, 2));
		}

		function convertPixelToAxial(x, y) {
			//first approximation
			/*
			var q = Math.round((x - 2/3 * y) / size);
			//var r = (4 * y) / 3 * size;
			var r = Math.round((4/3 * y) / size);
			
			var mousePoint = {x: x, y: y};

			console.log("(Q,R) = (" + q + "," + r + ")");
			
			var distance = euclideanDistance(convertAxialToPixel(q, r), mousePoint);

			console.log("DISTANCE: " + distance);

			var newQ = q, newR = r;

			for (var i = 0; i < neighbors.length; i++) {
				var qi = q + neighbors[i][0];
				var ri = r + neighbors[i][1];

				console.log("neighbors (Q,R) = (" + qi + "," + ri + ")");

				var newDistance = euclideanDistance(convertAxialToPixel(qi, ri), mousePoint);
				console.log("NEW DISTANCE: " + newDistance);
				if (distance > newDistance) {
					newQ = qi;
					newR = ri;
				}
			}

			console.log("NEW (Q,R) = (" + q + "," + r + ")");
			/**/

			//*

			var q = (x - 2/3 * y) / size;
			//var r = (4 * y) / 3 * size;
			var r = (4/3 * y) / size;

			//convert to cube coordinates
			var x = q;
			var z = r;
			var y = - x - z;
			
			var rx = Math.round(x);
			var rz = Math.round(z);
			var ry = Math.round(y);
			
			var xDiff = Math.abs(rx - x)
			var yDiff = Math.abs(ry - y)
			var zDiff = Math.abs(rz - z)
			
			if (xDiff > yDiff && xDiff > zDiff) {
				rx = - ry - rz;
			} else if (yDiff > zDiff) {
				ry = - rx - rz;
			} else{
				rz = -rx-ry;
			}
			
			console.log("(Q,R) = (" + rx + "," + rz + ")")
			//return cube coordinates
			//return {x: rx, y: ry, z: rz};
			/**/
		}
		
		var neighbors = [
			[1, 0], [1, -1], [0, -1],
			[-1, 0], [-1, 1], [0, 1]
		];

		function getMousePos(evt) {
			//*
			var rect = renderer.view.getBoundingClientRect();
			return {x: evt.clientX - rect.left, y: evt.clientY - rect.top };
			/**/
			/*
			console.log({x: evt.clientX, y: evt.clientY });
			return {x: evt.clientX, y: evt.clientY };
			/**/
		}
		
		renderer.view.addEventListener("click", function(event) {
			var mousePos = getMousePos(event);
			convertPixelToAxial(mousePos.x, mousePos.y);
		});

		function isoTile(filename) {
			return function(q, r) {
				var tile = PIXI.Sprite.fromFrame(filename);
				
				var cubePosition = convertAxialToPixel(q,r);
				
				tile.position.x = cubePosition.x;
				tile.position.y = cubePosition.y;

				// middle-center
				/*
				tile.anchor.x = 0.5;
				tile.anchor.y = 0.3652;
				/**/
				tile.anchor.x = anchor.x;
				tile.anchor.y = anchor.y;
				stage.addChild(tile);

				var textCoord = new PIXI.Text("(" + q + "," + r + ")", { font: "10px", fill: "Black", align: "center" });
				textCoord.anchor.x = textCoord.anchor.y = 0.5;
				textCoord.position.x = cubePosition.x;
				textCoord.position.y = cubePosition.y;
				stage.addChild(textCoord);

				var textCoord2 = new PIXI.Text("(" + cubePosition.x + "," + cubePosition.y + ")", { font: "10px", fill: "Black", align: "center" });
				textCoord2.anchor.x = textCoord2.anchor.y = 0.5;
				textCoord2.position.x = cubePosition.x;
				textCoord2.position.y = cubePosition.y + 10.0;
				stage.addChild(textCoord2);

				var g = new PIXI.Graphics();
				g.beginFill(0xFFCC00, 1);
				g.drawCircle(cubePosition.x, cubePosition.y, 1);
				stage.addChild(g);
			}
		}

		function drawMap(terrain, xOffset, yOffset) {
			var tileType, x, y, isoX, isoY, idx;

			for (var i = 0, iL = terrain.length; i < iL; i++) {
				for (var j = 0, jL = terrain[i].length; j < jL; j++) {
					// cartesian 2D coordinate
					x = j * tileWidth;
					y = i * tileHeight;

					// iso coordinate
					/*
					isoX = x - y;
					isoY = (x + y) / 2;
					/**/

					tileType = terrain[i][j];
					drawTile = tileMethods[tileType];
					//drawTile(isoX + xOffset, isoY + yOffset);
					//drawTile(x + xOffset, y + yOffset, j, i);
					drawTile(j, i);
				}
			}
		}

		loader.onComplete = start;
		loader.load();

		function start() {
			//drawMap(terrain, WIDTH / 2, tileHeight * 1.5);
			//drawMap(terrain, 0, 0);
			drawMap(terrain, tileWidth * 0.5, tileHeight * 0.5);

			var tile = PIXI.Sprite.fromFrame("tileAutumn.png");
			tile.position.x = 500;
			tile.position.y = 200;

			// middle-center
			tile.anchor.x = 0.5;
			tile.anchor.y = 0.5;
			stage.addChild(tile);

			function animate() {
				requestAnimFrame(animate);

				//tile.position.x += 0.1;

				renderer.render(stage);
			}
			requestAnimFrame(animate);
		}

		/*
		var imgUrl = 'http://upload.wikimedia.org/wikipedia/commons/thumb/0/0d/Ski_trail_rating_symbol-blue_square.svg/600px-Ski_trail_rating_symbol-blue_square.svg.png';

		var sprite = PIXI.Sprite.fromImage(imgUrl);
		sprite.position.set(0, 0);
		sprite.pivot.set(sprite.width/2, sprite.height/2);

		stage.addChild(sprite);
		*/
		
		/*
		// create a texture from an image path
		var texture = PIXI.Texture.fromImage("images/bunny.png");
		// create a new Sprite using the texture
		var bunny = new PIXI.Sprite(texture);

		// center the sprites anchor point
		bunny.anchor.x = 0.5;
		bunny.anchor.y = 0.5;

		// move the sprite t the center of the screen
		bunny.position.x = 200;
		bunny.position.y = 150;

		stage.addChild(bunny);
		/**/

		function animate() {

		    requestAnimFrame( animate );

			// just for fun, lets rotate mr rabbit a little
			//bunny.rotation += 0.1;

			//sprite.rotation += 0.1;

		    // render the stage   
		    renderer.render(stage);
		}

	</script>
</body>
</html>